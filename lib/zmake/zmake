#!/usr/bin/python

# file : zmake
# des : zmake file, python script
# author : zhaodongwei (joodaw@gmail.com)
# org : nju

import os
import sys
import getopt
import shutil
import glob

lib_list = []
root_list = []
app_list = []
src_set = set()
target_set = set()
target_list = []

complier = 'gcc'
gxx_flag = '-O 2'
gpp_flag = ''
com_flag = ''
output_dir = ''

def usage():
	print """zmake: help building your works.

	zmake   -n: init ZMAKE
	zmake     : build Makefile

	zmake   -u: update lib codes
	zmake   -b: build  libs
	sudo ./zmake -s: install zmake
"""

# ZMAKE related
def generate_ZMAKE():
	this_path = os.path.abspath('.')
	this_start = 0
	pre_index = 0
	index = 0
	while (True):
		pre_index = index
		index = this_path.find('/', this_start)
		if (index == -1):
			print 'I cannot find git root, in worng directory?'
			exit(3)
		git_path = this_path[0:index] + '/.git'
		if (os.path.exists(git_path)):
			break
		this_start = index + 1
	working_path = this_path[0:pre_index]

	f = open('ZMAKE', 'w')
	f.write('#This is a ZMAKE file generated by zmake\n')
	working_path = "root('%s')\n" % working_path
	f.write(working_path)
	f.write(
"""
#complier
COMPLIER('g++')

#gxx flag
GXX_FLAG('-O 2')

#output dir
OUTPUT_DIR('output')

#config lib
lib('app/lib/zlog')

#head file
header = './include/*'
src = './src/*'

app('exe', 'name', src, header)
app('static', 'libname.a', src, header)
"""
	)
	f.close()

# Makefile related
def generate_Makefile():
	try:
		execfile('ZMAKE')
	except:
		print 'I cannot generate Makefile, ZMAKE miss or syntex error?'
		exit(4)
	if (complier == 'gcc'):
		com_flag = gxx_flag
	elif (complier == 'g++'):
		com_flag = gxx_flag + gpp_flag
	else:
		print 'I cannot recognize complier'
		return 5
	makefile = open('Makefile', 'w')
	makefile.write('#Makefile generated by zmake\n')
	makefile.write('.PHONY: all\n')
	make_obj_include(makefile)
	if (0 != make_obj(makefile)):
		return 6
	make_clean(makefile)
	makefile.close()
	print 'Makefile made'

def COMPLIER(complier_item):
	global complier
	complier = complier_item.lower()

def GXX_FLAG(gxx_flag_item):
	global gxx_flag
	gxx_flag = gxx_flag_item

def GPP_FLAG(gpp_flag_item):
	global gpp_flag
	gpp_flag = gpp_flag_item

def OUTPUT_DIR(output_dir_item):
	global output_dir
	output_dir = output_dir_item + '/'
	if (os.path.exists(output_dir)):
		return 0
	else:
		try:
			os.mkdir(output_dir)
		except:
			print 'I cannot make output dir'
			return 7

def root(working_path):
	print working_path
	root_list.append(working_path)

def	lib(lib_path):
	print lib_path
	lib_list.append(lib_path)

def app(make_type, make_name, make_src, make_header):
	app_list.append([make_type, make_name, make_src, make_header])

def make_obj_include(makefile_handler):
	root_path = root_list[0] + '/'
	makefile_handler.write('all: ')
	app_target = set()
	for it in app_list:
		makefile_handler.write(it[1] + ' ')
	makefile_handler.write('\n')
	makefile_handler.write('lib_header=')
	for it in lib_list:
		makefile_handler.write('-I ' + root_path + it[:] + '/include \\\n')
	makefile_handler.write('\n')

	makefile_handler.write('lib_library=')
	for it in lib_list:
		lib_name = it[:].split('/')[-1]
		makefile_handler.write(root_path + it[:] + '/lib' + lib_name + '.a \\\n')
	makefile_handler.write('-lpthread\n')

def make_obj(makefile_handler):
	for it in app_list:
		headers = it[3]
		header_list = headers.split(',')
		header_dict = {}
		header_path_set = set()
		target_set.clear()
		for header in header_list:
			header_it = glob.glob(header)
			for header_item in header_it:
				tmp_list = header_item.split('/')
				header_dict[tmp_list[-1]] = header_item
				header_path_set.add('/'.join(tmp_list[0:len(tmp_list) - 1]))

		header_path = ''
		for h in header_path_set:
			header_path = header_path + '-I ' + h + ' '

		srcs = it[2]
		src_list = srcs.split(',')
		for src in src_list:
			src_it = glob.glob(src)
			for src_item in src_it:
				make_src(src_item, header_dict, header_path, makefile_handler)
				makefile_handler.write('\n')
		make_target(makefile_handler, it);
		header_path_set.clear()
		header_dict.clear()
	return 0

def make_src(src_file, header_dict, header_path, makefile_handler):
	tmp_list_1 = src_file.split('/')
	tmp_list_2 = (tmp_list_1[-1]).split('.')
	target_set.add(tmp_list_2[0] + '.o')
	if (src_file in src_set):
		return 0
	target_list.append(tmp_list_2[0] + '.o')
	makefile_handler.write(tmp_list_2[0] + '.o: ');
	makefile_handler.write(src_file + ' ');
	print_src_header(makefile_handler, src_file, header_dict)
	makefile_handler.write('\t' + complier + ' ' + com_flag + ' ');
	makefile_handler.write('-c -o ' + output_dir + tmp_list_2[0] + '.o' \
       + ' ' + src_file + ' ' + header_path  + ' ' + '$(lib_header)');
	src_set.add(src_file);

def make_target(makefile_handler, app_name):
	makefile_handler.write(app_name[1] + ':')
	for it in target_set:
		makefile_handler.write(it + ' ')
	makefile_handler.write('\n\t')
	if ('exe' == app_name[0]):
		makefile_handler.write(complier + ' -o ' + output_dir + app_name[1] + ' ')
		for it in target_set:
			makefile_handler.write(output_dir + it + ' ')
		makefile_handler.write('$(lib_library)');
		makefile_handler.write('\n\t@cp ' + output_dir + app_name[1] + ' .');
	if ('static' == app_name[0]):
		makefile_handler.write('ar cqs' + ' -o ' + output_dir + app_name[1] + ' ')
		for it in target_set:
			makefile_handler.write(output_dir + it + ' ')
	makefile_handler.write('\n');
	return 0

def make_clean(makefile_handler):
	makefile_handler.write('clean:\n\trm -rf ')
	for it in target_list:
		makefile_handler.write(output_dir + it + ' ')
	for it in app_list:
		makefile_handler.write(output_dir + it[1] + ' ')
		if ('exe' == it[0]):
			makefile_handler.write(it[1] + ' ')
	makefile_handler.write('\n')

def print_src_header(makefile_handler, fname, header_dict):
	f = open(fname, 'r');
	for line in f:
		if ('' == line.lstrip()):
			continue
		if ('#' != line.lstrip()[0]):
			continue
		tmp = line.lstrip()[1:]
		if ('include' != tmp.lstrip()[0:7]):
			continue
		tmp = tmp.lstrip()[7:]
		header = ''
		if ('\"' == tmp[1]):
			it = tmp.split('\"')
			header = it[1]
		elif ('<' == tmp[1]):
			it = tmp[2:].split('>')
			header = it[0]
		else:
			print 'I cannot parse header file for ' + fname
			return 1
		if (header in header_dict):
			makefile_handler.write(header_dict[header] + ' ')
	makefile_handler.write('\n')
	f.close()	

# arg parser and control
arg_has_s = 0
arg_has_u = 0
arg_has_b = 0
arg_has_n = 0
arg_has_x = 0
arg_count = 0
opts, args = getopt.getopt(sys.argv[1:], 'hsnubx:')
for op, value in opts:
	if (op == '-s'):
		arg_has_s = 1
	if (op == '-n'):
		arg_has_n = 1
	if (op == '-u'):
		arg_has_u = 1
	if (op == '-b'):
		arg_has_b = 1
	if (op == '-x'):
		arg_has_x = 1
		print value
	if (op == '-h'):
		usage()
		exit(0)
	arg_count += 1

if (arg_has_s):
	print 'install zmake, copying files ...'
	try:
		shutil.copyfile('./zmake', '/usr/bin/zmake')
		os.system('chmod +111 /usr/bin/zmake')
	except:
		print 'I cannot install zmake, permission denied?'
		exit(1)
	print 'zmake installed'
	exit(0)

if (arg_has_n):
	print 'building ZMAKE'
	try:
		generate_ZMAKE()
	except:
		print 'I cannot generate ZMAKE, permission denied?'
		exit(1)
	print 'ZMAKE generated'
	exit(0)

if (arg_has_u):
	print 'update lib code'

if(arg_has_b):
	print 'build libs'

if (0 == arg_count):
	generate_Makefile()

