#!/usr/bin/python

# file : zmake
# des : zmake, help building your works
# author : zhaodongwei (joodaw@gmail.com)
# org : nju

import os
import sys
import getopt
import shutil
import glob

lib_list    = set()
root_list   = []
head_list   = []
app_list    = []
src_set     = set()
target_set  = set()
target_list = []
lib_map     = {}

complier = 'gcc'
gxx_flag = '-O2'
gpp_flag = ''
com_flag = ''
link_flag  = ''
output_dir = ''

def usage():
	print """zmake: help building your works.

	zmake   -n: init ZMAKE
	zmake     : build Makefile

	zmake   -u: update lib codes
	zmake   -b: build  libs
	sudo ./zmake -s: install zmake
"""

ERR_DICT = {
'find_git_err':'I cannot find git path',
'find_this_lib_err':'I cannot find this lib path',
'map_lib_err':'I cannot orgnize relied libs',
'parse_lib_err':'I cannot parse relied libs',
'lib_miss_err':'I cannot find some libs, zmake -u first',
'lib_list_err':'I cannot make relied libs list',
'cp_zmake_err':'I cannot cp zmake, permission denied?',
'exec_zmake_err':'I cannot generate Makefile, ZMAKE miss or syntex error?',
'make_makefile_err':'I cannot make Makefile',
'parse_header_err':'I cannot parse header file',
'make_ZMAKE_err':'I cannot generate ZMAKE',
'make_output_err':"I cannot make output dir",
'complier_err':"I cannot recognize complier"
}

def err(err_code, appendtxt = ''):
	print '\033[31mERROR\033[0m: [' + err_code + '] ' + ERR_DICT.get(err_code, 'undefined err') + ' ' + appendtxt
	return 0

# ZMAKE related
def generate_ZMAKE():
	git_path = find_git_path()
	if (git_path == 1):
		return 1
	f = open('ZMAKE', 'w')
	f.write('#ZMAKE file generated by zmake\n\n')
	working_path = "#git root\nroot('%s')\n" % git_path
	f.write(working_path)
	f.write(
"""
#complier
COMPLIER('g++')

#gxx flag
GXX_FLAG('-O2')

#link flag
LINK_FLAG('-lpthread')

#output dir
OUTPUT_DIR('output')

#config lib
lib('app/lib/zlib')

#include folders
include('./include')

#head file
header = './include/*'
src = './src/*'

app('exe', 'name', src, header)
#app('static', 'libname.a', src, header)
"""
	)
	f.close()
	return 0

#find git path
def find_git_path():
	abs_path = os.path.abspath('.')
	p = abs_path.split('/')
	l = len(p)
	i = 1
	while (i <= l + 1):
		git = '/'.join(p[0:i]) + '/.git'
		if (os.path.exists(git)):
			break
		i += 1
	else:
		err('find_git_error')
		return 1
	git = ''
	while (i <= l):
		git = git + '../'
		i += 1
	return git

	abs_path = os.path.abspath('.')
	start = 0
	pidx = 0
	idx = 0
	while (True):
		pidx = idx
		idx = abs_path.find('/', start)
		if (idx == -1):
			err('find_git_err')
			return 1
		git_path = abs_path[0:idx] + '/.git'
		if (os.path.exists(git_path)):
			break
		start = idx + 1

	git_path = abs_path[0:pidx]
	return git_path

def find_this_lib_path():
	abs_path = os.path.abspath('.')
	start = 0
	idx = 0
	pidx = 0
	while (True):
		idx = abs_path.find('/', start)
		if (idx == -1):
			err('find_this_lib_err')
			return 1
		git_path = abs_path[0:idx] + '/.git'
		if (os.path.exists(git_path)):
			break
		start = idx + 1
		pidx = idx

	this_lib_path = abs_path[pidx + 1:]
	return this_lib_path

def map_lib():
	git_path = find_git_path()
	lib_path = find_this_lib_path()
	ret = parse_lib_map(git_path, lib_path)
	if (ret != 0):
		err('parse_lib_err')
		return 1
	ret = make_lib_list()
	if (ret != 0):
		err('lib_list_err')
		return 1
	return 0

def parse_lib_map(git_path, lib_path):
	zmake_path = git_path + '/' + lib_path + '/' + 'ZMAKE'
	if (not os.path.exists(zmake_path)):
		err('lib_miss_err', zmake_path)
		return 1
	zmake_file = open(zmake_path, 'r')
	for line in zmake_file:
		strs = line.lstrip()
		if (strs == ''):
			continue
		if (strs[0:3] != 'lib'):
			continue;
		strs = strs[3:].lstrip()
		if (strs[0] != '('):
			continue
		strs = strs[1:].lstrip()
		l = strs.split('\'');
		if (len(l) == 3):
			lib_map.setdefault(lib_path, [ ]).append(l[1])
			ret = parse_lib_map(git_path, l[1])
			if (ret != 0):
				err('parse_lib_err', l[1])
				return 1
			continue
		l = strs.split('\"');
		if (len(l) == 3):
			lib_map.setdefault(lib_path, [ ]).append(l[1])
			ret = parse_lib_map(git_path, l[1])
			if (ret != 0):
				err('parse_lib_err', l[1])
				return 1
			continue
		l = strs.split('\'\'\'');
		if (len(l) == 3):
			lib_map.setdefault(lib_path, [ ]).append(l[1])
			ret = parse_lib_map(git_path, l[1])
			if (ret != 0):
				err('parse_lib_err', l[1])
				return 1
			continue
		err('parse_lib_err', zmake_path)
		return 1

	zmake_file.close()
	return 0

def make_lib_list():
	for i in lib_map:
		for j in lib_map[i]:
			print j
			lib_list.add(j)
	return 0

# Makefile related
def generate_Makefile():
	global com_flag
	try:
		execfile('ZMAKE')
	except:
		err('exec_zmake_err')
		return 1
	if (complier == 'gcc'):
		com_flag = gxx_flag
	elif (complier == 'g++'):
		com_flag = gxx_flag + gpp_flag
	else:
		err('complier_err', complier)
		return 1

	ret = map_lib()
	if (ret != 0):
		err('map_lib_err')
		return 1

	makefile = open('Makefile', 'w')
	makefile.write('#Makefile generated by zmake, based on ZMAKE\n\n')
	makefile.write('.PHONY: all\n')
	ret = make_common(makefile)
	if (ret != 0):
		return ret
	ret = make_content(makefile)
	if (ret != 0):
		return ret
	ret = make_clean(makefile)
	if (ret != 0):
		return ret
	makefile.close()
	return 0

def COMPLIER(complier_item):
	global complier
	complier = complier_item.lower()

def GXX_FLAG(gxx_flag_item):
	global gxx_flag
	gxx_flag = gxx_flag_item

def GPP_FLAG(gpp_flag_item):
	global gpp_flag
	gpp_flag = gpp_flag_item

def LINK_FLAG(flag):
	global link_flag
	link_flag = flag

def OUTPUT_DIR(output_dir_item):
	global output_dir
	output_dir = output_dir_item + '/'
	if (os.path.exists(output_dir)):
		return 0
	else:
		try:
			os.mkdir(output_dir)
		except:
			err('make_output_err')
			return 1
	return 0

def root(working_path):
	root_list.append(working_path)

def lib(lib_path):
	return 0

def include(head):
	head_list.append(head)

def app(make_type, make_name, make_src, make_header):
	app_list.append([make_type, make_name, make_src, make_header])

def make_common(makefile_handler):
	root_path = root_list[0] + '/'
	makefile_handler.write('all: ')
	app_target = set()
	for it in app_list:
		makefile_handler.write(it[1] + ' ')
	makefile_handler.write('\n')
	makefile_handler.write('lib_header=')
	for it in lib_list:
		makefile_handler.write('-I ' + root_path + it[:] + '/include \\\n')
	makefile_handler.write('\n')

	makefile_handler.write('lib_library=')
	for it in lib_list:
		lib_name = it[:].split('/')[-1]
		makefile_handler.write(root_path + it[:] + '/lib' + lib_name + '.a \\\n')
	makefile_handler.write(link_flag + '\n\n')
	return 0

def make_content(makefile_handler):
	for it in app_list:
		headers = it[3]
		header_list = headers.split(',')
		header_dict = {}
		header_path_set = set()
		target_set.clear()
		for header in header_list:
			header_it = glob.glob(header)
			for header_item in header_it:
				tmp_list = header_item.split('/')
				header_dict[tmp_list[-1]] = header_item
				header_path_set.add('/'.join(tmp_list[0:len(tmp_list) - 1]))
		for header in head_list:
			header_it = glob.glob(header + '/*')
			for header_item in header_it:
				tmp_list = header_item.split('/')
				header_dict[tmp_list[-1]] = header_item
				header_path_set.add('/'.join(tmp_list[0:len(tmp_list) - 1]))

		header_path = ''
		for h in header_path_set:
			header_path = header_path + '-I ' + h + ' '

		srcs = it[2]
		src_list = srcs.split(',')
		for src in src_list:
			src_it = glob.glob(src)
			for src_item in src_it:
				ret = make_src(src_item, header_dict, header_path, makefile_handler)
				if (ret != 0):
					return ret
		ret = make_target(makefile_handler, it);
		if (ret != 0):
			return ret;
		header_path_set.clear()
		header_dict.clear()
	return 0

def make_src(src_file, header_dict, header_path, makefile_handler):
	tmp_list_1 = src_file.split('/')
	tmp_list_2 = (tmp_list_1[-1]).split('.')
	target_set.add(tmp_list_2[0] + '.o')
	if (src_file in src_set):
		return 0
	target_list.append(tmp_list_2[0] + '.o')
	makefile_handler.write(tmp_list_2[0] + '.o: ');
	makefile_handler.write(src_file + ' ');
	ret = print_included_header(makefile_handler, src_file, header_dict)
	if (ret != 0):
		return ret
	makefile_handler.write('\t' + complier + ' ' + com_flag + ' ');
	makefile_handler.write('-c -o ' + output_dir + tmp_list_2[0] + '.o' \
       + ' ' + src_file + ' ' + header_path  + ' ' + '$(lib_header)');
	makefile_handler.write('\n');
	src_set.add(src_file);
	return 0

def make_target(makefile_handler, app_name):
	makefile_handler.write(app_name[1] + ':')
	for it in target_set:
		makefile_handler.write(it + ' ')
	makefile_handler.write('\n\t')
	if ('exe' == app_name[0]):
		makefile_handler.write(complier + ' -o ' + output_dir + app_name[1] + ' ')
		for it in target_set:
			makefile_handler.write(output_dir + it + ' ')
		makefile_handler.write('$(lib_library)');
		makefile_handler.write('\n\t@cp ' + output_dir + app_name[1] + ' .');
	if ('static' == app_name[0]):
		makefile_handler.write('ar cqs' + ' -o ' + output_dir + app_name[1] + ' ')
		for it in target_set:
			makefile_handler.write(output_dir + it + ' ')
		makefile_handler.write('\n\t@cp ' + output_dir + app_name[1] + ' .');
	makefile_handler.write('\n');
	return 0

def make_clean(makefile_handler):
	makefile_handler.write('clean:\n\trm -rf ')
	for it in target_list:
		makefile_handler.write(output_dir + it + ' ')
	for it in app_list:
		makefile_handler.write(output_dir + it[1] + ' ')
		makefile_handler.write(it[1] + ' ')
	makefile_handler.write('\n')
	return 0

def print_included_header(makefile_handler, fname, header_dict):
	f = open(fname, 'r');
	for line in f:
		if ('' == line.lstrip()):
			continue
		if ('#' != line.lstrip()[0]):
			continue
		tmp = line.lstrip()[1:]
		if ('include' != tmp.lstrip()[0:7]):
			continue
		tmp = tmp.lstrip()[7:]
		header = ''
		if ('\"' == tmp[1]):
			it = tmp.split('\"')
			header = it[1]
		elif ('<' == tmp[1]):
			it = tmp[2:].split('>')
			header = it[0]
		else:
			err('parse_header_err', fname)
			return 1
		if (header in header_dict):
			makefile_handler.write(header_dict[header] + ' ')
	makefile_handler.write('\n')
	f.close()	
	return 0

# arg parser and control
arg_has_s = 0
arg_has_u = 0
arg_has_b = 0
arg_has_n = 0
arg_has_x = 0
arg_cnt = 0
opts, args = getopt.getopt(sys.argv[1:], 'hsnubx:')
for op, value in opts:
	if (op == '-s'):
		arg_has_s = 1
	if (op == '-n'):
		arg_has_n = 1
	if (op == '-u'):
		arg_has_u = 1
	if (op == '-b'):
		arg_has_b = 1
	if (op == '-x'):
		arg_has_x = 1
		print value
	if (op == '-h'):
		usage()
		exit(0)
	arg_cnt += 1

ret = 0
if (arg_has_s):
	print 'install zmake, copying files ...'
	try:
		shutil.copyfile('./zmake', '/usr/bin/zmake')
		os.system('chmod +111 /usr/bin/zmake')
	except:
		err('cp_zmake_err')
		exit(1)
	print 'zmake installed'
	exit(0)

if (arg_has_n):
	print 'building ZMAKE'
	ret = generate_ZMAKE()
	if (ret != 0):
		err('make_ZMAKE_err')
		exit(1)
	print 'ZMAKE generated'
	exit(0)

if (arg_has_u):
	print 'update lib code'

if(arg_has_b):
	print 'build libs'

if (arg_cnt == 0):
	print 'building Makefile'
	ret = generate_Makefile()
	if (ret != 0):
		err('make_makefile_err')
		exit(1)
	print 'Makefile generated'
	exit(0)
