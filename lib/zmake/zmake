#!/usr/bin/python

# file : zmake
# des : zmake file, python script
# author : zhaodongwei (joodaw@gmail.com)
# org : nju

import os
import sys
import getopt
import shutil
import glob

lib_list = []
root_list = []
app_list = []
src_set = set()
header_set = set()
header_file_set = set()

complier = 'gcc'
gxx_flag = '-O 2'
gpp_flag = ''
com_flag = ''

def usage():
	print """zmake: help building your works.

	zmake   -n: init ZMAKE
	zmake     : build Makefile

	zmake   -u: update lib codes
	zmake   -b: build  libs
	sudo ./zmake -s: install zmake
"""

# ZMAKE related
def generate_ZMAKE():
	this_path = os.path.abspath('.')
	this_start = 0
	pre_index = 0
	index = 0
	while (True):
		pre_index = index
		index = this_path.find('/', this_start)
		if (index == -1):
			print 'I cannot find git root, in worng directory?'
			exit(3)
		git_path = this_path[0:index] + '/.git'
		if (os.path.exists(git_path)):
			break
		this_start = index + 1
	working_path = this_path[0:pre_index]

	f = open('ZMAKE', 'w')
	f.write('#This is a ZMAKE file generated by zmake\n')
	working_path = "root('.%s')\n" % working_path
	f.write(working_path)
	f.write(
"""
#complier
COMPLIER('g++')

#gxx flag
GXX_FLAG('-O 2')

#config lib
lib('app/lib/zlog')

#head file
header = './include/*'
src = './src/*'

app('exe', 'name', src, header)
app('static', 'libname.a', src, header)
"""
	)
	f.close()

# Makefile related
def generate_Makefile():
	try:
		execfile('ZMAKE')
	except:
		print 'I cannot generate Makefile, ZMAKE miss or syntex error?'
		exit(4)
	if (complier == 'gcc'):
		com_flag = gxx_flag
	elif (complier == 'gxx'):
		com_flag = gxx_flag + gpp_flag
	else:
		print 'I cannot recognize complier'
		return 5
	makefile = open('Makefile', 'w')
	makefile.write('#Makefile generated by zmake\n')
	makefile.write('.phony: all\n')
	make_obj_include(makefile)
	if (0 != make_obj(makefile)):
		return 6

	makefile.close()
	print 'Makefile made'

def COMPLIER(complier_item):
	complier = complier_item.lower()

def GXX_FLAG(gxx_flag_item):
	gxx_flag = gxx_flag_item

def GPP_FLAG(gpp_flag_item):
	gpp_flag = gpp_flag_item

def root(working_path):
	print working_path
	root_list.append(working_path)

def	lib(lib_path):
	print lib_path
	lib_list.append(lib_path)

def app(make_type, make_name, make_src, make_header):
	app_list.append([make_type, make_name, make_src, make_header])

def make_obj_include(makefile_handler):
	root_path = root_list[0] + '/'
	makefile_handler.write('all: ')
	app_target = set()
	for it in app_list:
		makefile_handler.write(it[1] + ' ')
	makefile_handler.write('\n')
	makefile_handler.write('lib_header=')
	for it in lib_list:
		makefile_handler.write('-I ' + root_path + it[:] + ' \\\n')
		makefile_handler.write('-I ' + root_path + it[:] + '/include \\\n')
	makefile_handler.write('\n')

def make_obj(makefile_handler):
	for it in app_list:
		srcs = it[2]
		src_list = srcs.split(',')
		for src in src_list:
			src_it = glob.glob(src)
			for src_item in src_it:
				src_set.add(src_item)
		headers = it[3]
		header_list = headers.split(',')
		for header in header_list:
			header_it = glob.glob(header)
			for header_item in header_it:
				header_set.add(header_item)
				tmp_list = header_item.split('/')
				header_file_set.add(tmp_list[-1])

	for it in src_set:
		tmp_list_1 = it.split('/')
		tmp_list_2 = (tmp_list_1[-1]).split('.')
		makefile_handler.write(tmp_list_2[0] + '.o: ');
		makefile_handler.write(it + ' ');
		print_src_header(makefile_handler, it)
		makefile_handler.write('\t' + complier + ' ' + com_flag + ' ');
		makefile_handler.write('-o ' + tmp_list_2[0] + '.o' + ' ' + it + ' ' + '$(lib_header)');

	print complier
	print gxx_flag
	print gpp_flag

def print_src_header(makefile_handler, fname):
	f = open(fname, 'r');
	for line in f:
		if ('' == line.lstrip()):
			continue
		if ('#' != line.lstrip()[0]):
			continue
		tmp = line.lstrip()[1:]
		if ('include' != tmp.lstrip()[0:7]):
			continue
		tmp = tmp.lstrip()[7:]
		header = ''
		if ('\"' == tmp[1]):
			it = tmp.split('\"')
			header = it[1]
		elif ('<' == tmp[1]):
			it = tmp[2:].split('>')
			header = it[0]
		else:
			print 'I cannot parse header file for ' + fname
			return 1
		if (header in header_file_set):
			makefile_handler.write(header + ' ')
	makefile_handler.write('\n')
	f.close()	

# arg parser and control
arg_has_s = 0
arg_has_u = 0
arg_has_b = 0
arg_has_n = 0
arg_has_x = 0
arg_count = 0
opts, args = getopt.getopt(sys.argv[1:], 'hsnubx:')
for op, value in opts:
	if (op == '-s'):
		arg_has_s = 1
	if (op == '-n'):
		arg_has_n = 1
	if (op == '-u'):
		arg_has_u = 1
	if (op == '-b'):
		arg_has_b = 1
	if (op == '-x'):
		arg_has_x = 1
		print value
	if (op == '-h'):
		usage()
		exit(0)
	arg_count += 1

if (arg_has_s):
	print 'install zmake, copying files ...'
	try:
		shutil.copyfile('./zmake', '/usr/bin/zmake')
		os.system('chmod +111 /usr/bin/zmake')
	except:
		print 'I cannot install zmake, permission denied?'
		exit(1)
	print 'zmake installed'
	exit(0)

if (arg_has_n):
	print 'building ZMAKE'
	try:
		generate_ZMAKE()
	except:
		print 'I cannot generate ZMAKE, permission denied?'
		exit(1)
	print 'ZMAKE generated'
	exit(0)

if (arg_has_u):
	print 'update lib code'

if(arg_has_b):
	print 'build libs'

if (0 == arg_count):
	generate_Makefile()

